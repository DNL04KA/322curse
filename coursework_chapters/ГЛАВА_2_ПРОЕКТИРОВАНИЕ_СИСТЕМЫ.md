# 2 ПРОЕКТИРОВАНИЕ СИСТЕМЫ

## 2.1 Проектирование базы данных

Проектирование базы данных является одной из наиболее важных задач на первых этапах разработки информационной системы. Грамотно построенная база данных обеспечивает эффективное хранение данных, их актуальность и безопасность. Другим важным аспектом является удобство доступа к необходимой информации, возможность быстро её обрабатывать и предоставлять результаты.

Проектирование базы данных – это процесс последовательной детализации пользовательского представления о предметной области информационной системы и его преобразования сначала в концептуальную модель, описывающую объектную среду моделируемой предметной области, затем в логическую модель, определяющую представление прикладных программ о структуре базы данных, и в физическую модель данных, детально определяющую структуры данных и схему их размещения на устройствах внешней памяти.

В зависимости от сложности проекта можно ограничиться только логической или физической моделью. В данном подразделе реализуется физическая модель данных с помощью средств СУБД MySQL. Схема физической модели данных показана на рисунке 2.1.

**[Рисунок 2.1 – Физическая схема базы данных]**
*(Используйте diagram_2.1_database.puml для создания изображения)*

Схема содержит пять основных таблиц предметной области, используемых веб-приложением: **users**, **restaurants**, **dishes**, **orders** и **order_items**. Дополнительно в базе данных присутствует служебная таблица **migrations**, используемая Laravel для отслеживания выполненных миграций схемы базы данных, но она не отображена на концептуальной схеме, так как не содержит данных предметной области.

Таблица **restaurants** является одной из центральных для приложения. Она содержит сведения о ресторанах и кафе, которые участвуют в сервисе доставки. Каждая запись включает название заведения (name), описание (description), адрес (address), контактный телефон (phone), путь к изображению (image) и статус активности (is_active). Поля created_at и updated_at автоматически отслеживают время создания и последнего изменения записи.

Таблица **dishes** соответствует меню ресторанов. Здесь хранятся названия блюд (name), описания (description), цены (price), пути к изображениям (image), категории (category) для группировки блюд по типам (супы, вторые блюда, салаты, напитки, десерты), информация о питательной ценности (calories - калории, protein - белки, fat - жиры, carbs - углеводы) и статус доступности (is_available). Для соотнесения блюд с ресторанами используется внешний ключ restaurant_id, который ссылается на таблицу restaurants с каскадным удалением — при удалении ресторана автоматически удаляются все его блюда.

Таблица **orders** используется для хранения информации о заказах. Содержит данные о заказчике: имя (customer_name), email (customer_email), телефон (customer_phone), адрес доставки (delivery_address), общую сумму заказа (total_amount), статус обработки (status) со значениями pending (ожидает), confirmed (подтвержден), preparing (готовится), delivering (доставляется), delivered (доставлен) и cancelled (отменен), желаемое время доставки (delivery_time) и дополнительные заметки (notes). Для связи с зарегистрированными пользователями системы предусмотрен внешний ключ user_id, который может быть пустым (NULL) для гостевых заказов без регистрации.

Таблица **order_items** соответствует позициям в заказах и реализует связь многие-ко-многим между заказами и блюдами. Здесь хранятся ссылки на заказ (order_id) и блюдо (dish_id), количество порций (quantity), цена на момент заказа (price), которая фиксируется для предотвращения изменения стоимости заказа при изменении цен в меню, и специальные инструкции по приготовлению (special_instructions). При удалении заказа или блюда соответствующие записи в order_items удаляются автоматически благодаря каскадному удалению.

Таблица **users** предназначена для хранения информации о зарегистрированных пользователях. Включает имя пользователя (name), адрес электронной почты (email), который может быть пустым, контактный телефон (phone), являющийся уникальным и используемый для входа в систему, захэшированный пароль (password), дату регистрации (created_at) и роль в системе (is_admin). Поле is_admin определяет права доступа: значение true соответствует администратору с расширенными возможностями управления заказами и пользователями, false — обычному пользователю-клиенту.

Для обеспечения производительности системы на часто запрашиваемые поля добавлены индексы: на phone, email и is_admin в таблице users; на user_id, status и created_at в таблице orders; на restaurant_id, is_available и category в таблице dishes. Это позволяет значительно ускорить выполнение запросов на поиск, фильтрацию и сортировку данных.

## 2.2 Проектирование веб-приложения

Современные веб-приложения реализуются в рамках клиент-серверной архитектуры. В данной модели вычислительная нагрузка распределяется между серверами, предоставляющими ресурсы или сервисы, и клиентами, которые эти услуги потребляют. Клиент и сервер представляют собой программное обеспечение, которое может функционировать как на разных узлах сети, так и в пределах одной вычислительной системы. В силу необходимости обработки запросов от множества клиентов одновременно, серверные программы размещаются на специализированных вычислительных узлах с повышенными требованиями к производительности и надежности. Эти узлы, в совокупности с установленным на них программным обеспечением, принято называть серверами, тогда как термином «клиенты» обозначаются рабочие станции, с которых осуществляется доступ к сервисам.

В UML поведение моделируется посредством вариантов использования, специфицируемых независимо от реализации. Вариант использования (прецедент) – это описание множества последовательных действий (включая вариации), которые выполняются некоторым субъектом с целью получения результата, значимого для некоторого действующего лица. Вариант использования предполагает взаимодействие действующих лиц и системы или другого субъекта. Действующее лицо представляет собой логически связанное множество ролей, которые играют пользователи системы во время взаимодействия с ней. Действующими лицами могут быть как люди, так и автоматизированные системы.

Диаграмма вариантов использования для веб-приложения сервиса доставки еды представлена на рисунке 2.2.

**[Рисунок 2.2 – Диаграмма вариантов использования]**
*(Используйте diagram_2.2_FINAL.puml для создания изображения)*

Веб-приложение поддерживает работу двух типов пользователей: обычный пользователь и администратор.

Пользователю доступны следующие функции: регистрация на сайте с указанием имени, телефона и пароля; вход в аккаунт с обязательной проверкой учетных данных (показано отношением <<include>>); просмотр списка ресторанов; просмотр меню ресторанов с опциональными возможностями поиска блюд по названию и фильтрации по категориям (показано отношением <<extend>>); просмотр подробной информации о блюде, включая пищевую ценность; добавление блюд в корзину с указанием количества порций; просмотр корзины с опциональной возможностью изменения количества и удаления позиций (<<extend>>); оформление заказа с обязательным указанием адреса доставки и расчетом итоговой суммы (<<include>>); отслеживание статуса текущих заказов; просмотр истории всех совершённых заказов.

Администратору доступен весь функционал обычных пользователей (показано отношением обобщения) и дополнительные возможности управления: просмотр всех заказов в системе; управление заказами с обязательным изменением статуса (<<include>>) и опциональной отправкой уведомлений в Telegram администраторам (<<extend>>); управление пользователями системы с возможностью назначения или снятия прав администратора и блокирования учетных записей (<<extend>>).

Отношение <<include>> означает, что базовый вариант использования обязательно включает поведение другого варианта: вход в аккаунт всегда требует проверки учетных данных, а оформление заказа невозможно без указания адреса доставки и расчета суммы. Отношение <<extend>> указывает на опциональное расширение функциональности: просмотр меню может быть дополнен поиском или фильтрацией, но эти действия необязательны; изменение статуса заказа может сопровождаться отправкой уведомления, но это не обязательное условие.

Диаграмма компонентов – это структурная диаграмма языка унифицированного моделирования, она описывает особенности физического представления системы. Диаграмма компонентов позволяет определить архитектуру разрабатываемой системы, установив зависимости между программными компонентами.

На рисунке 2.3 изображена структура веб-приложения для сервиса доставки еды.

**[Рисунок 2.3 – Структура проекта]**
*(Используйте diagram_2.3_minimal.puml для создания изображения)*

Диаграмма показывает взаимосвязи клиентских и серверных компонентов программы. Клиентская часть представлена веб-браузером, который использует HTML5 для структуры страниц, CSS3 с фреймворком Bootstrap 5 для стилизации и JavaScript с Fetch API для асинхронных операций. Браузер отправляет HTTP-запросы веб-серверу и получает от него ответы в виде HTML-страниц.

Серверная часть построена на базе фреймворка Laravel и включает Laravel Artisan Web Server, который обрабатывает входящие HTTP-запросы на этапе разработки. Для продакшн-развертывания рекомендуется использовать Nginx или Apache с PHP-FPM. Запросы поступают в Router (routes/web.php), который выполняет маршрутизацию с применением middleware для аутентификации, проверки прав администратора, защиты от CSRF-атак и ограничения частоты запросов (rate limiting).

Проект следует архитектурному паттерну MVC (Model-View-Controller). Controllers обрабатывают входящие запросы, выполняют бизнес-логику и координируют взаимодействие между компонентами. Models (Eloquent ORM) обеспечивают доступ к данным в MySQL, автоматически используя подготовленные запросы для защиты от SQL-инъекций. Views (Blade Templates) содержат шаблоны страниц с автоматическим экранированием для защиты от XSS-атак. База данных MySQL хранит все данные приложения в таблицах users, restaurants, dishes, orders и order_items.

Диаграмма взаимодействия показывает взаимодействие, состоящее из набора объектов и их связей, включая передаваемые между ними сообщения. Диаграмма последовательности – это диаграмма взаимодействия, которая подчеркивает временной порядок сообщений. Изображается как таблица, в которой представлены объекты, расположенные вдоль оси X, и сообщения, упорядоченные по ходу времени – вдоль оси Y.

Диаграмма последовательности обычно иллюстрирует один конкретный вариант использования, при этом уровень детализации может отличаться в зависимости от контекста.

На рисунке 2.4 изображена диаграмма для варианта использования «Изменить статус заказа».

**[Рисунок 2.4 – Диаграмма последовательности для варианта использования «Изменить статус заказа»]**
*(Используйте diagram_2.4_minimal.puml для создания изображения)*

В сценарии работы «Изменить статус заказа» участвуют следующие объекты: Администратор, Браузер, Laravel Framework, Order Controller, Order Model и MySQL.

Сначала администратор открывает панель управления заказами, отправляя через браузер GET-запрос на адрес /admin/orders. Laravel передает управление методу index() контроллера OrderController, который через модель Order выполняет запрос к MySQL для получения списка всех заказов с сортировкой по дате создания. Полученные данные передаются в представление (view), которое формирует HTML-страницу со списком заказов и отправляет её в браузер для отображения администратору.

Далее администратор выбирает конкретный заказ для изменения статуса и новое значение статуса из выпадающего списка, после чего отправляет POST-запрос на адрес /admin/orders/5/status, где 5 — идентификатор заказа. Laravel применяет middleware для проверки аутентификации и прав администратора, затем передает управление методу updateStatus() контроллера OrderController.

Контроллер выполняет валидацию входных данных, проверяя корректность нового статуса. После успешной валидации контроллер через модель Order находит заказ с указанным идентификатором, выполняя SELECT-запрос к MySQL. Затем модель обновляет статус заказа, выполняя UPDATE-запрос к базе данных в рамках транзакции для обеспечения целостности данных.

После успешного обновления статуса в базе данных контроллер формирует редирект с flash-сообщением об успешном выполнении операции. Laravel генерирует HTTP-ответ с кодом 302 (редирект) и сообщением, которое отображается в браузере администратора в виде уведомления «Статус заказа изменен».

В случае возникновения ошибок (неуспешная валидация, заказ не найден, ошибка базы данных) контроллер возвращает пользователя на предыдущую страницу с сообщением об ошибке, и изменения в базе данных не применяются благодаря механизму транзакций MySQL.

