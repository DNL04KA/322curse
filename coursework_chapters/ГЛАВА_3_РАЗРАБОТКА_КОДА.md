# 3 РАЗРАБОТКА ПРОГРАММНОГО КОДА

Разработка программного обеспечения представляет собой ключевой этап создания информационной системы. В рамках данного этапа были установлены и настроены необходимые программные компоненты для реализации веб-приложения сервиса доставки еды. В качестве основного инструмента разработки выбран современный PHP-фреймворк Laravel версии 12, обеспечивающий высокую производительность и безопасность приложения. Для хранения данных использована реляционная СУБД MySQL версии 8.0+, которая обеспечивает надежную работу в многопользовательской среде и поддержку транзакций через InnoDB движок. Согласно разработанной на предыдущих этапах схеме базы данных, созданы соответствующие таблицы и связи между ними с использованием миграций Laravel. Произведена настройка веб-сервера Laravel Artisan для корректного функционирования приложения на этапе разработки.

Проект организован в соответствии со стандартной структурой Laravel и включает специализированные директории для различных компонентов системы. В корневой папке размещены основные конфигурационные файлы фреймворка, включая artisan - инструмент командной строки Laravel, composer.json - файл зависимостей проекта, package.json для frontend-зависимостей, а также служебные файлы для сборки frontend-ресурсов через Vite.

## 3.1 Структура проекта

Приложение организовано согласно архитектуре Laravel и включает следующие основные компоненты:

- **app/** - основная логика приложения, включающая контроллеры для обработки HTTP-запросов, модели Eloquent для работы с базой данных MySQL, middleware для промежуточной обработки запросов и сервисы для бизнес-логики;

- **bootstrap/** - файлы инициализации и загрузки приложения, включая app.php для регистрации middleware, exception handlers и routing;

- **config/** - конфигурационные файлы системы для настройки базы данных, сессий, кеша, почты и других компонентов Laravel;

- **database/** - миграции для создания и изменения схемы MySQL базы данных, сидеры для заполнения начальными данными и factories для генерации тестовых записей при разработке;

- **public/** - публично доступные файлы, включая index.php как точку входа приложения, статические ресурсы (CSS, JavaScript, изображения);

- **resources/** - шаблоны Blade для формирования HTML-страниц, CSS-файлы для стилизации и JavaScript для клиентской логики;

- **routes/** - файлы маршрутизации веб-приложения, определяющие соответствие URL-адресов методам контроллеров;

- **storage/** - директория для хранения временных файлов, логов приложения, загруженных файлов и кешированных данных.

## 3.2 Точка входа приложения

Основным файлом приложения, обеспечивающим обработку входящих HTTP-запросов, является public/index.php. Данный файл регистрирует автозагрузчик Composer для подключения всех зависимостей проекта, инициализирует ядро Laravel через bootstrap/app.php и перенаправляет запросы соответствующим обработчикам с применением middleware и routing.

```php
<?php

require __DIR__.'/../vendor/autoload.php';

$app = require_once __DIR__.'/../bootstrap/app.php';

$kernel = $app->make(Illuminate\Contracts\Http\Kernel::class);

$response = $kernel->handle($request = Illuminate\Http\Request::capture());

$response->send();

$kernel->terminate($request, $response);
```

Файл выполняет захват входящего HTTP-запроса, передачу его ядру Laravel для обработки через цепочку middleware и routing, формирование HTTP-ответа и его отправку клиенту, после чего выполняет завершающие операции через метод terminate.

## 3.3 Система маршрутизации

Маршрутизация запросов реализована в файле routes/web.php с использованием декларативного подхода Laravel. Каждый маршрут связывает URL-адрес с конкретным методом контроллера и может включать middleware для аутентификации, авторизации и других проверок.

```php
<?php

use Illuminate\Support\Facades\Route;

// Главная страница и рестораны
Route::get('/', [App\Http\Controllers\RestaurantController::class, 'index'])
    ->name('home');
Route::resource('restaurants', App\Http\Controllers\RestaurantController::class);

// Блюда
Route::get('/dishes/{dish}', [App\Http\Controllers\DishController::class, 'show'])
    ->name('dishes.show');

// Поиск
Route::get('/search', [App\Http\Controllers\SearchController::class, 'index'])
    ->name('search');

// Корзина и заказы (требуют аутентификации)
Route::middleware(['auth'])->group(function () {
    Route::get('/cart', [App\Http\Controllers\CartController::class, 'index'])
        ->name('cart.index');
    Route::post('/cart/add/{dish}', [App\Http\Controllers\CartController::class, 'add'])
        ->name('cart.add')
        ->middleware('throttle:60,1'); // Rate limiting
    
    Route::get('/orders/create', [App\Http\Controllers\OrderController::class, 'create'])
        ->name('orders.create');
    Route::post('/orders', [App\Http\Controllers\OrderController::class, 'store'])
        ->name('orders.store')
        ->middleware('throttle:10,1'); // Rate limiting
    
    Route::get('/orders/{order}', [App\Http\Controllers\OrderController::class, 'show'])
        ->name('orders.show');
    Route::get('/user/orders', [App\Http\Controllers\UserOrderController::class, 'index'])
        ->name('user.orders.index');
});

// Аутентификация
Route::get('/login', [App\Http\Controllers\Auth\LoginController::class, 'showLoginForm'])
    ->name('login');
Route::post('/login', [App\Http\Controllers\Auth\LoginController::class, 'login'])
    ->middleware('throttle:5,1'); // Rate limiting для входа

Route::get('/register', [App\Http\Controllers\Auth\RegisterController::class, 'showRegistrationForm'])
    ->name('register');
Route::post('/register', [App\Http\Controllers\Auth\RegisterController::class, 'register'])
    ->middleware('throttle:3,1'); // Rate limiting для регистрации

Route::post('/logout', [App\Http\Controllers\Auth\LoginController::class, 'logout'])
    ->name('logout')
    ->middleware('auth');

// Админ-панель (требует аутентификации и прав администратора)
Route::middleware(['auth', 'admin'])->prefix('admin')->name('admin.')->group(function () {
    Route::get('/orders', [App\Http\Controllers\OrderController::class, 'adminIndex'])
        ->name('orders.index');
    Route::patch('/orders/{order}/status', [App\Http\Controllers\OrderController::class, 'updateStatus'])
        ->name('orders.update-status');
    
    Route::resource('users', App\Http\Controllers\AdminUserController::class);
});
```

Все маршруты определяются с использованием HTTP-методов (GET, POST, PATCH, DELETE) и связаны с конкретными методами контроллеров. Laravel автоматически обрабатывает параметры маршрутов, применяет middleware для проверки прав доступа и CSRF-защиты форм, а также генерирует URL через функцию route(). Применение rate limiting (throttle) предотвращает атаки методом перебора и защищает от чрезмерной нагрузки на сервер.

## 3.4 Контроллеры

Контроллеры реализуют логику обработки запросов и являются посредниками между моделями и представлениями согласно паттерну MVC. Они выполняют валидацию входных данных, взаимодействуют с моделями для получения или изменения данных в MySQL, применяют бизнес-логику и возвращают представления или JSON-ответы.

Пример контроллера для работы с заказами:

```php
<?php

namespace App\Http\Controllers;

use App\Models\Order;
use App\Models\OrderItem;
use App\Models\Dish;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

class OrderController extends Controller
{
    public function store(Request $request)
    {
        // Валидация данных с пользовательскими сообщениями
        $request->validate([
            'customer_name' => 'required|string|max:255',
            'customer_phone' => 'required|string|max:20',
            'delivery_address' => 'required|string|max:1000',
        ]);

        $cart = session()->get('cart', []);
        if (empty($cart)) {
            return redirect()->route('cart.index')
                ->with('error', 'Корзина пуста!');
        }

        // Расчет суммы заказа с проверкой доступности блюд
        $total = 0;
        foreach ($cart as $dishId => $item) {
            $dish = Dish::find($dishId);
            if ($dish && $dish->is_available) {
                $total += $dish->price * $item['quantity'];
            }
        }

        // Создание заказа в транзакции для обеспечения целостности данных
        $order = DB::transaction(function () use ($request, $cart, $total) {
            $order = Order::create([
                'user_id' => auth()->id(),
                'customer_name' => $request->customer_name,
                'customer_phone' => $request->customer_phone,
                'delivery_address' => $request->delivery_address,
                'total_amount' => $total,
                'status' => 'pending',
            ]);

            // Создание позиций заказа
            foreach ($cart as $dishId => $item) {
                $dish = Dish::find($dishId);
                if ($dish && $dish->is_available) {
                    OrderItem::create([
                        'order_id' => $order->id,
                        'dish_id' => $dish->id,
                        'quantity' => $item['quantity'],
                        'price' => $dish->price, // Фиксируем цену на момент заказа
                    ]);
                }
            }

            return $order;
        });

        // Очистка корзины после успешного создания заказа
        session()->forget('cart');
        
        return redirect()->route('orders.success')
            ->with('success', 'Заказ успешно оформлен!');
    }

    public function adminIndex()
    {
        // Eager loading для предотвращения N+1 проблемы
        $orders = Order::with(['user', 'orderItems.dish'])
            ->orderBy('created_at', 'desc')
            ->paginate(20);

        return view('admin.orders.index', compact('orders'));
    }
    
    public function show(Order $order)
    {
        // Авторизация: только владелец заказа или администратор
        if (auth()->id() !== $order->user_id && !auth()->user()->is_admin) {
            abort(403, 'Доступ запрещен');
        }
        
        return view('orders.show', compact('order'));
    }
}
```

Вышеуказанный контроллер демонстрирует операцию создания заказа. Сначала выполняется валидация входных данных для предотвращения некорректного ввода. Затем происходит создание заказа в базе данных MySQL в рамках транзакции, что гарантирует атомарность операции - либо заказ создается полностью со всеми позициями, либо изменения откатываются при возникновении ошибки. Метод adminIndex использует eager loading для загрузки связанных данных одним запросом, что предотвращает проблему N+1 запросов и повышает производительность.

## 3.5 Модели и работа с базой данных

Модели Eloquent обеспечивают объектно-реляционное отображение (ORM) и предоставляют удобный интерфейс для работы с базой данных MySQL. Они автоматически управляют связями между таблицами, выполняют CRUD-операции и используют подготовленные запросы (prepared statements) для защиты от SQL-инъекций.

Пример модели для работы с заказами:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Order extends Model
{
    protected $fillable = [
        'user_id', 'customer_name', 'customer_email', 
        'customer_phone', 'delivery_address', 'total_amount', 
        'status', 'delivery_time', 'notes'
    ];

    protected $casts = [
        'total_amount' => 'decimal:2',
        'delivery_time' => 'datetime',
    ];

    // Связь с пользователем (один ко многим)
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    // Связь с позициями заказа (один ко многим)
    public function orderItems()
    {
        return $this->hasMany(OrderItem::class);
    }

    // Связь с блюдами через промежуточную таблицу (многие ко многим)
    public function dishes()
    {
        return $this->belongsToMany(Dish::class, 'order_items')
            ->withPivot('quantity', 'price', 'special_instructions')
            ->withTimestamps();
    }
}
```

Модель Order определяет массив $fillable для защиты от массового присваивания (mass assignment), указывая, какие поля можно безопасно заполнять из пользовательского ввода. Массив $casts автоматически преобразует типы данных при извлечении из MySQL и сохранении обратно. Методы связей (user, orderItems, dishes) определяют отношения между таблицами, позволяя легко получать связанные данные через Eloquent ORM без написания SQL-запросов вручную.

## 3.6 Представления

Пользовательский интерфейс реализован с использованием Blade-шаблонизатора Laravel, который обеспечивает удобный синтаксис для создания HTML-страниц с динамическими данными. Представления содержат HTML-разметку, стилизованную с помощью Bootstrap 5, и PHP-код в специальном синтаксисе Blade.

```blade
@extends('layouts.app')

@section('content')
<div class="container">
    <h1>Оформление заказа</h1>
    
    @if(session('success'))
        <div class="alert alert-success alert-dismissible fade show">
            {{ session('success') }}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
    @endif

    @if($errors->any())
        <div class="alert alert-danger">
            <ul class="mb-0">
                @foreach($errors->all() as $error)
                    <li>{{ $error }}</li>
                @endforeach
            </ul>
        </div>
    @endif

    <form action="{{ route('orders.store') }}" method="POST">
        @csrf
        
        <div class="mb-3">
            <label class="form-label">Имя и фамилия</label>
            <input type="text" name="customer_name" 
                   class="form-control @error('customer_name') is-invalid @enderror" 
                   value="{{ old('customer_name', auth()->user()->name) }}" required>
            @error('customer_name')
                <div class="invalid-feedback">{{ $message }}</div>
            @enderror
        </div>
        
        <div class="mb-3">
            <label class="form-label">Телефон</label>
            <input type="tel" name="customer_phone" 
                   class="form-control @error('customer_phone') is-invalid @enderror"
                   value="{{ old('customer_phone', auth()->user()->phone) }}" required>
            @error('customer_phone')
                <div class="invalid-feedback">{{ $message }}</div>
            @enderror
        </div>
        
        <div class="mb-3">
            <label class="form-label">Адрес доставки</label>
            <input type="text" name="delivery_address" 
                   class="form-control @error('delivery_address') is-invalid @enderror" 
                   value="{{ old('delivery_address') }}"
                   placeholder="Улица, дом, квартира" required>
            @error('delivery_address')
                <div class="invalid-feedback">{{ $message }}</div>
            @enderror
        </div>
        
        <button type="submit" class="btn btn-success">Оформить заказ</button>
    </form>
</div>
@endsection
```

Blade использует директиву @csrf для автоматической вставки CSRF-токена, защищающего от атак подделки межсайтовых запросов. Директива @error выводит сообщения валидации для конкретных полей. Функция old() восстанавливает введенные значения после неуспешной валидации. Все выводимые переменные автоматически экранируются через синтаксис {{ }}, что предотвращает XSS-атаки.

## 3.7 Конфигурация базы данных

Параметры подключения к базе данных MySQL определены в конфигурационном файле config/database.php. Все чувствительные настройки (хост, порт, имя базы, пользователь, пароль) вынесены в файл .env для обеспечения безопасности и удобства конфигурирования на разных окружениях.

```php
'mysql' => [
    'driver' => 'mysql',
    'url' => env('DB_URL'),
    'host' => env('DB_HOST', '127.0.0.1'),
    'port' => env('DB_PORT', '3306'),
    'database' => env('DB_DATABASE', 'food_order'),
    'username' => env('DB_USERNAME', 'root'),
    'password' => env('DB_PASSWORD', ''),
    'unix_socket' => env('DB_SOCKET', ''),
    'charset' => 'utf8mb4',
    'collation' => 'utf8mb4_unicode_ci',
    'prefix' => '',
    'prefix_indexes' => true,
    'strict' => true,
    'engine' => 'InnoDB',
],
```

Настройки включают указание InnoDB в качестве движка базы данных для поддержки транзакций и внешних ключей, использование кодировки utf8mb4 для поддержки всех символов Unicode включая эмодзи, включение строгого режима (strict mode) для предотвращения некорректных данных. Параметр engine => 'InnoDB' гарантирует ACID-совместимость операций с базой данных.

## 3.8 Безопасность приложения

В приложении реализованы множественные уровни защиты. Laravel автоматически применяет CSRF-защиту для всех POST, PUT, PATCH и DELETE запросов через middleware VerifyCsrfToken. Eloquent ORM использует подготовленные запросы (prepared statements) для всех операций с MySQL, что полностью исключает SQL-инъекции. Blade автоматически экранирует все выводимые данные через синтаксис {{ }}, защищая от XSS-атак. Пароли пользователей хешируются с использованием алгоритма bcrypt с cost factor 10. Rate limiting ограничивает частоту запросов на критичные эндпоинты (вход, регистрация, создание заказов) для предотвращения атак методом перебора и защиты от DDoS.

## 3.9 Обеспечение качества и надежности

Для обеспечения качества кода и предотвращения ошибок в проекте используются следующие подходы:

**Валидация данных** - все пользовательские данные проходят строгую проверку на стороне сервера с использованием Form Request классов Laravel. Реализована валидация формата телефона, email, обязательных полей и уникальности данных.

**Защита от SQL-инъекций** - использование Eloquent ORM и подготовленных запросов полностью исключает возможность SQL-инъекций. Все запросы к базе данных MySQL выполняются через защищенный интерфейс.

**CSRF-защита** - все формы защищены CSRF-токенами, что предотвращает межсайтовую подделку запросов. Laravel автоматически генерирует и проверяет токены для каждой сессии.

**Хеширование паролей** - пароли пользователей хешируются с использованием алгоритма bcrypt перед сохранением в базу данных, что обеспечивает их надежную защиту.

**Middleware для контроля доступа** - реализован AdminMiddleware для разграничения прав доступа между обычными пользователями и администраторами системы.

**Ручное тестирование** - все критические функции приложения (регистрация, создание заказов, изменение статусов, отслеживание) прошли комплексное ручное тестирование на различных сценариях использования.

В результате реализации создано полнофункциональное веб-приложение для заказа еды из местных ресторанов, соответствующее всем требованиям курсового проекта и готовое к практическому использованию. Приложение обеспечивает удобный интерфейс для пользователей, эффективную систему управления заказами для администраторов, высокий уровень безопасности данных и производительность при работе с MySQL базой данных.

